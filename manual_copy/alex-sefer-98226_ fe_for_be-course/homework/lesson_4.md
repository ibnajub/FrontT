# Блок 1
1. Получить от юзера число.

    Получить сумму квадратов всех чисел от 1 до числа, которое ввел юзер.

    Пример:
   - Юзер ввел 4
   - (1 * 1) + (2 * 2) + (3 * 3) + (4 * 4) = 30
   - Вывести в консоль результат

    Привести во вторую степень можно через оператор `**`. 

    3 `**` 2 = 9


2. Есть массив [3, 5, 12, 9, 23, 93, 17]

    Отфильтровать его так, чтобы остались только те числа, которые больше 2 и меньше 20. И потом получить их сумму.


3. Дан массив [[1, 6, 3, '6'], [10, 15, 13, '10']]. Найти сумму элементов, которые являются числами и кратны двум

4. Написать функцию, которая устанавливает новые свойства в объект.

    Функция принимает в себя 3 аргумента - key, value, obj

    - key - свойство, которое хотим добавить. Принимаем это от юзера.

    - value - значение свойства. Принимаем это от юзера.

    - obj - объект, в который хотим добавить новое свойство.

    Если юзер ввел ключ, который уже есть в объекте, то выводим сообщение - "Уже есть", если ключа нет, то устанавливаем его в объект.

# Блок 2


1. Написать функцию bindFunc, которая принимает в себя 2 + аргументов (Точно должна принять 2 аргумента, а дальше сколько угодно).

- 1 аргумент - какая-то функция

- 2 аргумент - значение контекста

- 3 + ... аргументы - любое кол-во аргументов

Эта функция, должна устанавливать контекст для функции, которая в первом аргументе, **и возвращать эту функцию с новым контекстом**.

Сам контекст, который мы хотим установить, находиться во втором аргументе

2. Написать функцию, которая **не принимает никаких аргументов**. В теле функции написать логику для нахождения суммы значений любого количества ключей **(значения ключей должны быть больше нуля)** из переданного контекста.

Обращаться к objectA напрямую нельзя :)

Пример

```
const func = function() {
 this.a + this.b + .....
}
const objectA = {
 a: 1,
 b: 2,
 c: 3,
}
```

3. Написать функцию, которая возвращает новый массив, в котором должны быть только четные **числа**, которые больше двуx и меньше 10. Новый массив будет состоять из значений ключа values из контекста, если такого ключа нет, то выводим сообщение "Не найдено".

Обращаться к valObject0 напрямую нельзя :)

Если хотите использовать map, то внутри map this всегда равен глобальному объекту. Чтобы это поменять передаем нужное значение this во второй аргумент map -

arr.map(() => {}, this);

Пример:

```
function getNewArray() {
 ....
};
const valObject0 = {
 values: [1, '2', 4, 8, '8',  3, 10, null, false],
};
const result = getNewArray...; // Ссылаясь на массив ключа values из valObject0 [4, 8]
```

# Блок 3 


1. Дан объект с городами и странами.

Написать функцию getCity. Эта функция (getCity) должна вернуть новый массив, элементы которого будут преобразованы в данный формат: <Столица> - это <Страна>.

Доступ к объекту может быть любым (через контекст, напрямую и т.д.)

Можно использовать Object.entries метод )

```
const citiesAndCountries = {
	'Киев': 'Украина',
	'Нью-Йорк': 'США',
	'Амстердам': 'Нидерланды',
	'Берлин': 'Германия',
	'Париж': 'Франция',
	'Лиссабон': 'Португалия',
	'Вена': 'Австрия',
};
const result = getCity(); // ['Киев - это Украина', 'Нью-Йорк - это США', ... и т.д.]
```

2. Создать объект с названиями дней недели. Где ключами будут ru и en, a значением свойства ru будет массив с названиями дней недели на русском, а en - на английском.

После написать функцию которая будет выводить в консоль название дня недели пользуясь выше созданным объектом (доступ к объекту можно получить напрямую).

Все дни недели начинаются с 1 и заканчиваются цифрой 7 (1- понедельник, 7 - воскресенье).

Функция принимает в аргументы 2 параметра:

- lang - название языка дня недели
- day - число дня недели

Можно вспомнить про метод indexOf(). А может можно и без него :)

```
const namesOfDays = {
    ru: ['Понедельник', 'Вторник', 'Среда', ... , 'Воскресенье'],
    en: ['Monday', 'Tuesday', 'Wednesday', ... , 'Sunday'],
}
------------------------------------------------
// Пример 1
function getNameOfDay(lang, datNumber){
    ... Your code
}
getNameOfDay('en', 7) // 'Sunday'
------------------------------------------------
// Пример 2
function getNameOfDay(lang, datNumber){
    
    ... Your code
}
getNameOfDay('ru', 3) // 'Среда'
```

3. Написать универсальную функцию setProto, которая принимает в себя 2 аргумента (currentObj, protoObj). Функция должна устанавливать прототип (protoObj) для currentObj. То есть после вызова функции мы должны получить результат:

```
const person = {
    name: 'Vlad'
};
const person1 = {
    age: 1
};
function setProto (currentObj, protoObj) {
    // code
}
setProto(person1, person);
// Теперь прототипом для объекта person1 выступает объект person
```

4. Создать базовый объект person. Этот объект должен выступать в роли прототипа для объекта person1.

В объекте person должны быть такие методы:
- метод для **установки** имени и возраста (setName, setAge)
- метод для **получения** имени и возраста (getName, getAge)
- метод для валидации возраста (ageValidation)

```
person1.setName(...); // установили новое имя
person1.getName(); // имя
person1.setAge(...); // установили возраст
person1.getAge(); // получили возраст
```

Метод ageValidation вызывается при вывозе метода setAge (то есть внутри метода setAge). Метод ageValidation должен как-то проверить возраст, который мы вводим в setAge. Если возраст, который мы ввели, меньше 18, то записываем в age слово 'Validation Error', а есть введенный возраст больше 18, то вписываем в age это значение.

ageValidation только проверяет данные, он ничего не записывает (в ageValidation не должно быть this.age = age)

``` 
person1.setAge(1); // передать возраст можно как угодно
person1.getAge(); // 'Validation Error'
person1.setAge(20); // передать возраст можно как угодно
person1.getAge(); // Новое значение - 20
```
